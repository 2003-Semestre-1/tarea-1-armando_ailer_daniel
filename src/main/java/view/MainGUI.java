/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package view;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import static model.reader.leerArchivo;


/* @author Ailer Alvarado - Armando Arce - Daniel Rojas*/
public class MainGUI extends javax.swing.JFrame {
    private static List<String>[] memoria = new ArrayList[100];
    private static final HashMap<String, Integer> registros_valores = new HashMap<String, Integer>() {{
            put("AC", 0);
            put("AX", 0);
            put("BX", 0);
            put("CX", 0);
            put("DX", 0);
    }};
    private static final HashMap<String, String> operaciones = new HashMap<String, String>() {{
            put("LOAD", "0001");
            put("STORE", "0010");
            put("MOV", "0011");
            put("SUB", "0100");
            put("ADD", "0101");
    }};
    private static final HashMap<String, String> registros = new HashMap<String, String>() {{
            put("AX", "0001");
            put("BX", "0010");
            put("CX", "0011");
            put("DX", "0100");
    }};
    
    /**
     * Creates new form MainGUI
     */
    public MainGUI() {
        try { // Cambiar el LookAndFeel a Windows
            UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
            System.err.println("Error al cambiar el tema: " + ex.getMessage());
        }
        initComponents();
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        sp_tabla = new javax.swing.JScrollPane();
        tabla = new javax.swing.JTable();
        menubar = new javax.swing.JMenuBar();
        menu = new javax.swing.JMenu();
        menu_open = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Tarea 1");
        setLocation(new java.awt.Point(0, 0));
        setMaximumSize(new java.awt.Dimension(1280, 720));
        setMinimumSize(new java.awt.Dimension(640, 480));
        setSize(new java.awt.Dimension(640, 480));

        sp_tabla.setEnabled(false);
        sp_tabla.setFocusable(false);

        tabla.getTableHeader().setReorderingAllowed(false); // Evitar que el usuario mueva las columnas
        tabla.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "CODIGO ASM", "COD BINARIO", "AC", "AX", "BX"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tabla.setColumnSelectionAllowed(true);
        tabla.setEnabled(false);
        sp_tabla.setViewportView(tabla);

        menu.setText("File");

        menu_open.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        menu_open.setText("Open");
        menu_open.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menu_openActionPerformed(evt);
            }
        });
        menu.add(menu_open);

        menubar.add(menu);

        setJMenuBar(menubar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(sp_tabla, javax.swing.GroupLayout.DEFAULT_SIZE, 628, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addComponent(sp_tabla, javax.swing.GroupLayout.DEFAULT_SIZE, 436, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * Aasigna el valor dado en "valor_asignado" al registro especificado por "registro_a_asignar".
     * La función hace uso de la variable global "registros_valores".
     * @param registro_a_asignar el registro al cual se le asignará un nuevo valor.
     * @param valor_asignado el valor que se asignará al registro especificado.
     */
    public static void mov(String registro_a_asignar, Integer valor_asignado) {
        registros_valores.put(registro_a_asignar, valor_asignado);
    }
    
    /**
     * Toma el valor del registro especificado por "registro_por_tomar" y lo asigna a "AC".
     * La función hace uso de la variable global "registros_valores".
     * @param registro_por_tomar el registro del cual se tomará el valor a asignar a "AC".
     */
    public static void load(String registro_por_tomar) {
        int valor_por_tomar = registros_valores.get(registro_por_tomar);
        registros_valores.put("AC", valor_por_tomar);
    }

    /**
    * Toma el valor actual en "AC" y lo asigna al registro especificado por "registro_por_actualizar".
    * La función hace uso de la variable global "registros_valores".
    * @param registro_por_actualizar el registro al cual se le asignará el valor actual en "AC".
    */
    public static void store(String registro_por_actualizar) {
        registros_valores.put(registro_por_actualizar, registros_valores.get("AC"));
    }

    /**
     * Toma el valor del registro especificado por "registro_a_sumar" y lo suma al valor actual en "AC".
     * La función hace uso de la variable global "registros_valores".
     * @param registro_a_sumar el registro cuyo valor se sumará al valor actual en "AC".
     */
    public static void add(String registro_a_sumar) {
        int valor_a_sumar = registros_valores.get(registro_a_sumar);
        int nuevo_valor = registros_valores.get("AC") + valor_a_sumar;
        registros_valores.put("AC", nuevo_valor);
    }

    /**
     * Toma el valor del registro especificado por "registro_a_restar" y lo resta al valor actual en "AC".
     * La función hace uso de la variable global "registros_valores".
     * @param registro_a_restar el registro cuyo valor se restará al valor actual en "AC".
     */
    public static void sub(String registro_a_restar) {
        int valor_a_restar = registros_valores.get(registro_a_restar);
        int nuevo_valor = registros_valores.get("AC") - valor_a_restar;
        registros_valores.put("AC", nuevo_valor);
    }

    /**
    * Convierte un número entero en su representación binaria de 8 bits,
    * teniendo en cuenta el signo del número.
    * @param num El número entero a convertir.
    * @return La representación binaria de 8 bits del número.
    */
    public static String intToBinary8(int num) {
        String binaryString = Integer.toBinaryString(Math.abs(num)); // convertir el valor absoluto a binario
        binaryString = String.format("%8s", binaryString).replace(' ', '0'); // completar con ceros a la izquierda
        if (num < 0) { // si el número es negativo, cambiar el bit de signo
            binaryString = "1" + binaryString.substring(1);
        } else {
            binaryString = "0" + binaryString.substring(1);
        }
        return binaryString;
    }

    
    /**
     * Toma una lista de cadenas de una línea de código y usa un mapa de operaciones y un mapa de registros ya definidos, 
     * y devuelve una cadena que representa la línea de código en binario.
     * 
     * @param linea La lista de cadenas que representa la línea de código a parsear.
     * @return Una cadena que representa la línea de código en binario.
     */
    public static String parseLine(List<String> linea) {
        String operador = linea.get(0);
        String registro = linea.get(1);
        String valor = "00000000";
        if (linea.size() == 3) {
            int numero = Integer.parseInt(linea.get(2));
            valor = intToBinary8(numero);
        }
        String codigo = operaciones.get(operador);
        String registroBin = registros.get(registro);
        return codigo + " " + registroBin + " " + valor;
    }

    /**
    * Busca un segmento de memoria no utilizado de n líneas consecutivas, 
    * empezando por el índice inicial especificado.
    * 
    * @param indiceInicial El índice inicial a partir del cual buscar.
    * @return Un array de dos elementos que contiene el índice inicial y 
    * final del segmento encontrado, o un array con [-1, -1] si no se encontró ninguno.
    */
    private static int[] buscarSegmentoUsado(int indiceInicial) {
        int indiceActual = indiceInicial;
        while (indiceActual < memoria.length && memoria[indiceActual].isEmpty()) {
            indiceActual++;
        }
        if (indiceActual == memoria.length) {
            // No se encontró ningún segmento con información
            return new int[] {-1, -1};
        }
        // Se encontró un segmento con información
        int indiceFinal = indiceActual;
        while (indiceFinal < memoria.length && !memoria[indiceFinal].isEmpty()) {
            indiceFinal++;
        }
        return new int[] {indiceActual, indiceFinal-1};
    }
  
    private void menu_openActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menu_openActionPerformed
        boolean flag_continuar = true;
        JFileChooser chooser = new JFileChooser();
        if (tabla.getModel().getRowCount()!=0){
            int respuesta = JOptionPane.showConfirmDialog(null, "Ya existe un archivo cargado exitosamente\n¿Está seguro de que desea continuar?", "Confirmación", JOptionPane.YES_NO_OPTION);
            flag_continuar = respuesta == JOptionPane.YES_OPTION;
        }
        if (flag_continuar){
            chooser.setCurrentDirectory(new File(System.getProperty("user.home") + "/Desktop"));
            chooser.setAcceptAllFileFilterUsed(false); // Deshabilitar el filtro predeterminado
            FileNameExtensionFilter filter = new FileNameExtensionFilter("Archivos ASM", "asm");
            chooser.setFileFilter(filter);
            int result = chooser.showOpenDialog(null);
            if (result == JFileChooser.APPROVE_OPTION) {
                String path = chooser.getSelectedFile().getPath();
                System.out.println("Archivo seleccionado: \n\t" + path);
                memoria = leerArchivo(path, memoria, true);
                int[] segmentoUsado = buscarSegmentoUsado(10);

                DefaultTableModel modelo = (DefaultTableModel) tabla.getModel();
                modelo.setNumRows(0);
                for (int i = segmentoUsado[0]; i < segmentoUsado[1]+1; i++) {
                    //System.out.println(i + " : " + memoria[i]);// Imprime la memoria 
                    String temp_cod_asm = memoria[i].get(0);
                    if (temp_cod_asm.equals("MOV")){
                        temp_cod_asm += " " + memoria[i].get(1) +", " + memoria[i].get(2);
                        mov(memoria[i].get(1), Integer.valueOf(memoria[i].get(2)));
                    } else {
                        temp_cod_asm += " " + memoria[i].get(1);
                        switch (memoria[i].get(0)){
                            case "LOAD":
                                load(memoria[i].get(1));
                                break;
                            case "STORE":
                                store(memoria[i].get(1));
                                break;
                            case "ADD":
                                add(memoria[i].get(1));
                                break;
                            case "SUB":
                                sub(memoria[i].get(1));
                                break;
                        }
                    }
                    
                    modelo.addRow(new Object[] {
                        temp_cod_asm,                   // ASM
                        parseLine(memoria[i]),          // Binario
                        registros_valores.get("AC"),    // AC | AX | BX
                        registros_valores.get("AX"),    // AX
                        registros_valores.get("BX")     // BX
                    });
                }
                tabla.setModel(modelo);
            }
        }
    }//GEN-LAST:event_menu_openActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        /* Create and display the form */
        for (int i = 0; i < memoria.length; i++) { memoria[i] = new ArrayList<>(); } // Limpeamos la memoria
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MainGUI().setVisible(true);
            }
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu menu;
    private javax.swing.JMenuItem menu_open;
    private javax.swing.JMenuBar menubar;
    private javax.swing.JScrollPane sp_tabla;
    private javax.swing.JTable tabla;
    // End of variables declaration//GEN-END:variables
}
